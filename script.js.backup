// Simple Horizontal Scroll Controller
window.addEventListener('load', function () {
    // Elements
    const portfolioSection = document.querySelector('.portfolio-section');
    const customScrollbar = document.querySelector('.custom-scrollbar');
    const customScrollbarThumb = document.querySelector('.custom-scrollbar-thumb');
    if (!portfolioSection || !customScrollbar || !customScrollbarThumb) {
      console.error('Required elements not found'); return;
    }

    // Dimensions cache
    let scrollWidth = 0, clientWidth = 0, maxScroll = 0, scrollbarWidth = 0;
    
    // Scrollbar easing state for trailing effect
    let currentThumbPos = 0;
    let targetThumbPos = 0;
    let scrollbarAnimating = false;
    let scrollbarAnimationFrame = null;
    
    function updateDimensions() {
      scrollWidth = portfolioSection.scrollWidth;
      clientWidth = portfolioSection.clientWidth;
      maxScroll = Math.max(0, scrollWidth - clientWidth);
      void customScrollbar.offsetHeight; // Force layout recalculation for Safari
      scrollbarWidth = customScrollbar.getBoundingClientRect().width || customScrollbar.offsetWidth;
    }
    
    // Animate scrollbar thumb to target position with trailing effect
    function animateScrollbarThumb() {
      if (!scrollbarAnimating) return;
      
      const diff = targetThumbPos - currentThumbPos;
      
      if (Math.abs(diff) < 0.1) {
        currentThumbPos = targetThumbPos;
        scrollbarAnimating = false;
        applyScrollbarTransform();
      } else {
        const easingFactor = 0.15;
        currentThumbPos += diff * easingFactor;
        applyScrollbarTransform();
        scrollbarAnimationFrame = requestAnimationFrame(animateScrollbarThumb);
      }
    }
    
    // Apply the transform to the scrollbar thumb
    function applyScrollbarTransform() {
      const thumbWidth = Math.max(50, (clientWidth / scrollWidth) * scrollbarWidth);
      
      customScrollbarThumb.style.width = thumbWidth + 'px';
      customScrollbarThumb.style.transform = `translate3d(${currentThumbPos}px,0,0)`;
      
      // Calculate gradient position based on scroll position
      const scrollLeft = portfolioSection.scrollLeft;
      const t = maxScroll > 0 ? scrollLeft / maxScroll : 0;
      const p = Math.max(0, Math.min(1, t));
      
      customScrollbarThumb.style.background = `linear-gradient(90deg,
        transparent 0%,
        transparent ${Math.max(0, (p - 0.3) * 100)}%,
        rgba(255,255,255,0.1) ${Math.max(0, (p - 0.2) * 100)}%,
        rgba(255,255,255,0.4) ${Math.max(0, (p - 0.1) * 100)}%,
        rgba(255,255,255,0.7) ${Math.max(0, (p - 0.05) * 100)}%,
        #FFFFFF ${p * 100}%,
        rgba(255,255,255,0.7) ${Math.min(100, (p + 0.05) * 100)}%,
        rgba(255,255,255,0.4) ${Math.min(100, (p + 0.1) * 100)}%,
        rgba(255,255,255,0.1) ${Math.min(100, (p + 0.2) * 100)}%,
        transparent ${Math.min(100, (p + 0.3) * 100)}%,
        transparent 100%)`;
    }
    
    // Update scrollbar position
    function updateScrollbar() {
      // Recalculate dimensions to ensure accuracy (especially after media loads)
      updateDimensions();
      
      const scrollLeft = portfolioSection.scrollLeft;
      
      if (maxScroll > 0 && scrollbarWidth > 0) {
        const thumbWidth = Math.max(50, (clientWidth / scrollWidth) * scrollbarWidth);
        const maxThumbPos = scrollbarWidth - thumbWidth;
        // Calculate target position, ensuring it can reach the edge
        targetThumbPos = Math.min(maxThumbPos, Math.max(0, (scrollLeft / maxScroll) * maxThumbPos));
        
        if (!scrollbarAnimating) {
          scrollbarAnimating = true;
          scrollbarAnimationFrame = requestAnimationFrame(animateScrollbarThumb);
        }
      }
    }
    
    // Initialize scrollbar position after dimensions are ready
    function initializeScrollbar() {
      updateDimensions();
      if (maxScroll > 0 && scrollbarWidth > 0) {
        const scrollLeft = portfolioSection.scrollLeft;
        const thumbWidth = Math.max(50, (clientWidth / scrollWidth) * scrollbarWidth);
        const maxThumbPos = scrollbarWidth - thumbWidth;
        currentThumbPos = targetThumbPos = Math.min(maxThumbPos, Math.max(0, (scrollLeft / maxScroll) * maxThumbPos));
        applyScrollbarTransform();
      }
    }

    // Simple vertical scroll -> horizontal scroll conversion
    portfolioSection.addEventListener('wheel', (e) => {
      e.preventDefault();
      const scrollDelta = e.deltaY * 0.5; // Simple conversion factor
      portfolioSection.scrollLeft += scrollDelta;
    }, { passive: false });

    // Update scrollbar on scroll
    portfolioSection.addEventListener('scroll', updateScrollbar, { passive: true });

    // Click-to-seek on scrollbar
    customScrollbar.addEventListener('click', (e) => {
      updateDimensions(); // Ensure dimensions are current
      const rect = customScrollbar.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const ratio = clickX / scrollbarWidth;
      portfolioSection.scrollLeft = ratio * maxScroll;
      updateScrollbar();
    }, { passive: true });

    // Prevent thumb clicks from triggering scrollbar clicks
    customScrollbarThumb.addEventListener('click', (e) => e.stopPropagation(), { passive: true });

    // Resize handler
    window.addEventListener('resize', () => {
      updateDimensions();
      initializeScrollbar();
      updateScrollbar();
    }, { passive: true });

    // Wait for media to load before initializing scrollbar
    const mediaElements = document.querySelectorAll('img, video');
    let pendingMedia = mediaElements.length;
    
    function initializeAfterMediaLoad() {
      // Use double requestAnimationFrame to ensure layout is complete
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          initializeScrollbar();
          updateScrollbar();
        });
      });
    }
    
    if (pendingMedia > 0) {
      mediaElements.forEach((el) => {
        const done = () => {
          pendingMedia--;
          if (pendingMedia === 0) {
            // All media loaded, now initialize scrollbar with correct dimensions
            initializeAfterMediaLoad();
          }
        };
        
        if (el.complete || (el.readyState >= 2)) {
          done();
        } else {
          el.addEventListener('load', done, { once: true, passive: true });
          el.addEventListener('loadedmetadata', done, { once: true, passive: true });
        }
      });
    } else {
      // No media to wait for, initialize immediately
      initializeAfterMediaLoad();
    }
});

